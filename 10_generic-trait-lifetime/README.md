# 10. 제네릭 타입, 트레잇, 라이프타임

모든 프로그래밍 언어는 중복되는 개념을 효율적으로 처리하기 위한 도구를 가지고 있음

`Rust`에서는 제네릭(generic)이 그 역할을 맡는데, **제네릭은 구체(concrete) 타입 혹은 기타 속성에 대한 추상화된 대역**  
컴파일과 실행 시점에 제네릭들이 **무슨 타입으로 채워지는지 알 필요 없이** 제네릭의 동작이나 다른 제네릭과의 관계를 표현할 수 있음

### 함수를 추출하여 중복 없애기

제네릭은 여러 가지 타입을 나타내는 자리표시자의 위치에 특정 타입을 집어넣는 것으로 코드 중복을 제거할 수 있게 해줌

### [개요 관련 코드](./src/main.rs)

## 10.1 제네릭 데이터 타입

제네릭을 사용하면 함수 시그니처나 구조체의 아이템에 다양한 구체적 데이터 타입을 사용할 수 있도록 정의할 수 있음

### 제네릭 함수 정의

함수 시그니처 내 매개변수와 반환 값의 데이터 타입 위치에 제네릭을 사용함

```rust
fn largest<T>(list: &[T]) -> T { list[0] }
```

### 제네릭 구조체 정의

문법은 구조체 이름 바로 뒤 꺾쇠 괄호에 타입 매개변수 이름을 선언하고, 구조체 정의 내 구체적 데이터 타입을 지정하던 곳에 제네릭 타입을 대신 사용

```rust
struct Point<T> {
    x: T,
    y: T,
}
```

제네릭 타입 매개변수는 원하는 만큼 여러 개를 정의할 수 있지만, 많으면 많아질수록 코드 가독성은 떨어짐  
만약 코드에서 **많은 수의 제네릭 타입이 필요함**을 알게 되었다면, **코드를 리팩터링해서 작은 부분들로 나누는 것을 고려**해야 할 수도 있음

### 제네릭 열거형 정의

구조체처럼 열거형도 배리언트에 제네릭 데이터 타입을 갖도록 정의할 수 있음

```rust
enum Option<T> {
    Some(T),
    None,
}
```

`Option<T>` 열거형은 `T` 타입에 대한 제네릭이며, `T` 타입을 들고 있는 `Some` 배리언트와 아무런 값도 들고 있지 않은 `None` 배리언트를 가짐

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

작성한 코드에서 보유하는 값의 타입만 다른 구조체나 열거형이 여러 개 있음을 발견했을 때는 제네릭 타입을 사용해 코드 중복을 제거할 수 있음

### 제네릭 메서드 정의

구조체 정의에서 사용한 제네릭 타입 매개변수와, 구조체의 메서드 시그니처 내에서 사용하는 제네릭 타입 매개변수가 항상 같은 것은 아님

### 제네릭 코드의 성능

제네릭 타입의 사용이 구체적인 타입을 사용했을 때와 비교해서 **전혀 느려지지 않음**

`Rust`는 컴파일 타임에 **제네릭을 사용하는 코드를 단형성화**함

> 단형성화(monomorphization): 제네릭 코드를 실제 구체 타입으로 채워진 특정한 코드로 바꾸는 과정  
> 이 과정에서, 컴파일러는 제네릭 함수를 만들 때 거친 과정을 정반대로 수행  
> 즉, 컴파일러는 제네릭 코드가 호출된 곳을 전부 찾고, 제네릭 코드가 호출할 때 사용된 구체 타입으로 코드를 생성

#### 단형성화 예제


- 단형성화 전 코드
  ```rust
  fn main() {
      let integer = Some(5);
      let float = Some(5.0);
  }
  ```
- 단형성화 후 코드
  ```rust
  enum Option_i32 {
    Some(i32),
    None,
  }
  enum Option_f64 {
    Some(f64),
    None,
  }
  fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
  }
  ```

제네릭 `Option<T>`가 컴파일러에 의해 특정한 정의들로 대체되었음  
`Rust` 컴파일러가 제네릭 코드를 각 인스턴스의 명시적인 타입으로 변경해주는 덕분에, 굳이 런타임 비용을 줄이기 위해 수동으로 직접 각 타입마다 중복된 코드를 작성할 필요가 없음

> 단형성화 과정은 `Rust` 제네릭을 런타임에 극도로 효율적으로 만들어줌


### [제네릭 관련 코드](./src/example/generic.rs)

---

## 10.2 트레잇으로 공통된 동작을 정의하기 

> **트레잇(trait): 특정한 타입을 가지고 있으면서 다른 타입과 공유할 수 있는 기능을 정의**

트레잇을 사용하면 공통된 기능을 추상적으로 정의할 수 있음  
트레잇 바운드(trait bound)를 이용하면 어떤 제네릭 타입 자리에 특정한 동작을 갖춘 타입이 올 수 있음을 명시

> 다른 언어에서 흔히 인터페이스(`interface`)라고 부르는 기능과 유사

### 트레잇 정의하기

**타입의 동작은 해당 타입에서 호출할 수 있는 메서드로 구성**  
만약에 다양한 타입에서 동일한 메서드를 호출할 수 있다면, 이 타입들은 **동일한 동작을 공유**한다고 표현 가능  
트레잇 정의는 메서드 시그니처를 그룹화하여 특정 목적을 달성하는 데 필요한 일련의 동작을 정의하는 것

트레잇은 본문에 여러 메서드를 가질 수 있음  
메서드 시그니처는 한 줄에 하나씩 나열되며, 각 줄은 세미콜론으로 끝남

### 특정 타입에 트레잇 구현하기

어떤 타입에 대한 트레잇을 구현하는 것은 평범한 메서드를 구현하는 것과 비슷함  
다른 점은 `impl` 뒤에 구현하고자 하는 트레잇의 이름을 적고, 그다음 `for` 키워드와 트레잇을 구현할 타입을 명시한다는 점

`impl` 블록 안에서 트레잇에 정의된 메서드 시그니처를 집어넣되, 구현하고자 하는 동작을 채워 넣음

이렇게 트레잇을 구현한 구조체는 보통의 메서드를 호출하는 것과 같은 방식으로 트레잇 메서드를 호출할 수 있음

> 유일한 차이점은 **크레이트 사용자가 타입 뿐만 아니라 트레잇도 스코프로 가져와야 한다**는 점

트레잇을 사용하기 위해서는 사용할 크레이트에 의존적은 다른 크레이트들 또한 스코프로 가져와서 자신들의 타입에 대해 구현할 수 있음

#### 트레잇 구현의 제약사항

트레잇이나 트레잇을 구현할 타입 중 둘 중 하나는 반드시 **자신의 크레이트 것이어야 해당 타입에 대한 트레잇을 구현**할 수 있음

> 우리가 만든 크레이트의 일부 기능으로 표준 라이브러리 트레잇인 `Display` 등을 구현할 수 있음  
> 그러나, 우리가 만든 크레이트에서는 `Vec<T>`에 대한 `Display` 트레잇을 구현할 수 없음
> 
> 이 제약은 프로그램의 특성 중 하나인 **일관성(coherence)**, 보다 자세히는 **고아 규칙(orphan rule)**에서 나옴  
> 이 규칙으로 인해 **다른 사람의 코드가 자신의 코드를 망가뜨릴 수 없으며**, 반대도 마찬가지  
> 이 규칙이 없다면 두 크레이트가 동일한 타입에 동일한 트레잇을 구현할 수 있게 되고, `Rust`는 어떤 구현체를 이용해야 할지 알 수 없게 됨

### 기본 구현

타입에 트레잇을 구현할 때마다 모든 메서드를 구현할 필요는 없도록 트레잇의 **메서드에 기본 동작을 제공**할 수도 있음  
이러면 특정한 타입에 트레잇을 구현할 때 기본 동작을 유지할지 혹은 오버라이드 할지 선택할 수 있음

> 어떤 메서드를 오버라이딩하는 구현을 하면 해당 메서드의 기본 구현을 호출할 수 없음

### 매개변수로서의 트레잇

#### 트레잇 바운드 문법

**트레잇 바운드(trait bound)**는 `impl trait` 문법과 같은 좀더 기다란 형식의 문법적 설탕  
트레잇 바운드는 아래와 같이 생김

```rust
pub fn notify<T: Summary>(item: &T) {
  println!("Breaking news! {}", item.summarize());
}
```

트레잇 바운드는 꺾쇠 괄호 안의 제네릭 타입 매개변수 선언에 붙은 콜론(`:`) 뒤에 위치함

`impl trait` 문법이 단순한 상황에서는 편리하고 코드를 더 간결하게 만들어주는 반면, 트레잇 바운드 문법은 더 복잡한 상황을 표현할 수 있음  

```rust
pub fn notify(item1: &impl Summary, item2: &impl Summary) {}
```

만약 위에서 서로 다른 타입이어도 상관없다면 `impl trait` 문법 사용도 적절함

```rust
pub fn notify<T: Summary>(item1: &T, item2: &T) {}
```

하지만 두 매개변수가 같은 타입으로 강제되어야 한다면 위처럼 사용해야 함  
매개변수의 타입으로 지정된 제네릭 타입 `T`는 함수를 호출할 때 `item1`, `item2` 인수 값의 구체적인 타입이 반드시 동일하도록 제한

#### `+` 구문으로 트레잇 바운드를 여럿 지정하기

**트레잇 바운드는 여러 개 지정될 수 있음**  

```rust
// pub fn notify(item: &(impl Summary + Display)) {}
pub fn notify<T: Summary + Display>(item: &T) {}
```

두 개의 트레잇 바운드가 지정됐으니, `notify` 본문에서는 `item`의 `summarize` 메서드를 호출할 수도 있고 `item`을 `{}`로 포맷팅할 수도 있음

#### `where` 조항으로 트레잇 바운드 정리하기

트레잇 바운드가 너무 많아지면 문제가 생김  
제네릭마다 트레잇 바운드를 갖게 되면, 여러 제네릭 타입 매개변수를 사용하는 함수는 함수명과 매개변수 사이에 너무 많은 트레잇 바운드 정보를 담게 될 가능성이 있음

```rust
// fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {}
fn some_function<T, U>(t: &T, u: &U) -> i32
  where T: Display + Clone,
        U: Clone + Debug
{}
```

트레잇 바운드로 도배되지 않고, 평범한 함수처럼 함수명과 매개변수 목록, 반환 타입이 붙어 있으니, 함수 시그니처를 읽기 쉬워짐

### 트레잇을 구현하는 타입을 반환하기

`impl trait` 문법을 반환 타입 위치에 써서 어떤 트레잇을 구현한 타입의 값을 반환시키는 데에도 사용 가능

### 트레잇 바운드를 사용해 조건부로 메서드 구현하기

제네릭 타입 매개변수를 사용하는 `impl` 블록에 트레잇 바운드를 이용하면, **지정된 트레잇을 구현하는 타입에 대해서만 메서드를 구현**할 수도 있음

타입이 특정 트레잇을 구현하는 경우에만 해당 타입에 트레잇을 구현할 수도 있음  
트레잇 바운드를 만족하는 **모든 타입에 대해 트레잇을 구현하는 것을 포괄 구현(blanket implementations)**이라 하며, `Rust` 표준 라이브러리 내에서 광범위하게 사용 중

```rust
impl<T: Display> ToString for T {
  // --snip--
}
```

`Display` 트레잇이 구현된 거의 모든 타입에서 `to_string()` 메서드를 호출할 수 있는건 표준 라이브러리의 이 포괄 구현 덕분

```rust
fn main() {
    let s = 3.to_string();
}
```

> 트레잇과 트레잇 바운드를 사용하면 제네릭 타입 매개변수로 코드 중복을 제거하면서 특정 동작을 하는 제네릭 타입이 필요하다는 사실을 컴파일러에게 전달할 수 있음  
> 컴파일러는 트레잇 바운드를 이용하여 코드에 사용된 구체적인 타입들이 올바른 동작을 제공하는지 검사  
> 동작 타입 언어에서는 이런 경우 런타임 에러 발생  
> `Rust`는 **컴파일 시점에 에러를 발생시켜 코드를 실행하기도 전에 문제를 해결**하도록 강제
> 
> 따라서 런타임에 해당 동작을 구현하는지 검사하는 코드를 작성할 필요가 없음  
> `Rust`는 **제네릭의 유연성과 성능 둘 다 놓치지 않음**

---

## 10.3 라이프타임으로 참조자의 유효성 검증하기