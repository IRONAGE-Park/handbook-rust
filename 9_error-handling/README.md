# 9. 에러 처리

`Rust`는 에러를 복구 가능한(recoverable) 에러와 복구 불가능한(unrecoverable) 에러 두 가지 범주로 묶음

- 복구 가능한 에러
  - "파일을 찾을 수 없음" 등
  - 사용자에게 문제를 보고하고 명령을 재시도하도록 원함
- 복구 불가능한 에러
  - 잘못된 배열 인덱스 참조

대부분의 언어는 예외 처리(exception)와 같은 메커니즘을 이용하여 이 두 종류를 구분하지 않고 같은 방식으로 처리하지만, `Rust`에는 예외 기능이 없음  
대신, 복구 가능한 에러를 위한 `Result<T, E>` 타입과 복구 불가능한 에러가 발생했을 때 프로그램을 종료하는 `panic!` 매크로를 제공

## 9.1 `panic!`으로 복구 불가능한 에러 처리하기

코드에서 나쁜 일이 일어나고 거기에 할 수 있는 행동이 존재하지 않을 때, `panic!` 매크로를 사용할 수 있음  

#### 패닉을 일으키는 방법

1. 잘못된 인덱스 접근과 같은 기본적으로 패닉을 일으킬 동작 발생
2. `panic!` 매크로 명시적 호출

#### 패닉의 동작

1. 실패 메시지 출력
2. 되감기(unwind)
3. 스택 청소
4. 종료

패닉이 발생했을 때 그 패닉의 근원을 쉽게 추적하기 위해 환경 변수를 통하여 `Rust`가 호출 스택을 보여주도록 할 수 있음

#### `panic!`에 대응하여 스택을 되감거나 그만두기

`panic!`이 발생하면 프로그램은 되감기(unwinding)을 시작하는데, 이는 `Rust`가 패닉을 발생시킨 각 함수로부터 스택을 거꾸로 훑어가면서 데이터를 청소한다는 뜻  
하지만 이 작업은 비용이 발생하기 때문에 데이터 정리 작업 없이 즉각 종료되는 그만두기(aborting)을 선택할 수 있음

프로그램이 사용하고 있던 메모리는 운영체제가 청소해주어야 함.  
프로젝트 내에서 결과 바이너리를 가능한 작게 만들고 싶다면, `Cargo.toml` 내에서 적합한 `[profile]` 섹션에 `panic = abort`를 추가하여 설정할 수 있음

- 릴리즈 모드에서 설정 예시
  
  ```toml
  [profile.release]
  panic = 'abort'
  ```

### `panic!` 백트레이스 이용하기

코드의 버그 때문에 라이브러리로부터 `panic!` 호출이 발생할 때 예제

`C`에서 데이터 구조의 끝을 넘어서 읽는 시도는 정의되지 않은 동작  
메모리가 해당 데이터 구조의 소유가 아닐지라도, 그 데이터 구조의 해당 요소에 상응하는 메모리 위치에 있는 모든 값을 가져올 수 있음

이러한 것을 버퍼 초과 읽기(buffer overread)라 하며, 접근이 허용되어서는 안 되는 데이터를 읽기 위해 어떤 공격자가 배열 뒤에 저장된 데이터를 읽어낼 요량으로 인덱스를 다루게 된다면, 이는 보안 취약점으로 이어질 수 있음

#### `RUST_BACKTRACE` 환경 변수

`RUST_BACKTRACE` 환경 변수를 설정하여 에러의 원인이 무엇인지 정확하게 백트레이스할 수 있음

> 백트레이스(backtrace)
> 
> 어떤 지점에 도달하기까지 호출한 모든 함수의 목록

- 백트레이스 읽는 요령
  - 위에서부터 시작하여 작성한 파일이 보일 때까지 읽는 것
  - 그 곳이 바로 문제를 일으킨 지점

- 환경변수 적용하는 방법
- `Rust` 실행 명령(`cargo run`) 앞에 환경변수 선언
  
    ```bash
    RUST_BACKTRACE=1 cargo run
    ```

> 실제 출력값은 운영체제 및 `Rust` 버전에 따라 다를 수 있음

이러한 정보로 백트레이스를 얻기 윗해서는 디버그 심볼이 활성화되어 있어야 함  
디버그 심볼은 여기처럼 `cargo build`나 `cargo run`을 `--release` 플래그 없이 실행했을 때 기본적으로 실행 됨

프로그램이 패닉에 빠지지 않도록 하려면 직접 작성한 파일이 언급된 첫 줄부터 조사해야 함  
이러한 패닉을 고칠 방법은 범위를 벗어난 벡터 인덱스로 요소를 요청하지 않도록 하는 것

### [`panic!` 관련 코드](./src/example/panic.rs)

---

## 9.2 `Result`로 복구 가능한 에러 처리하기

대부분의 에러는 프로그램을 전부 중단해야 할 정도로 심각하지 않음  
함수 실패 원인은 쉽게 해석하고 대응할 수 있는 경우가 많음

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

- `T`와 `E`는 제네릭 타입 매개변수
  - `T`는 성공한 경우에 `Ok` 배리언트 안에 반환될 값의 타입
  - `E`는 실패한 경우에 `Err` 배리언트 안에 반환될 에러의 타입

> `Result`는 반환하고자 하는 성공적인 값과 에러 값이 달라질 수 있는 다양한 상황에서 대응할 수 있음

### 서로 다른 에러에 대해 매칭하기

#### `Result<T, E>`와 `match` 사용에 대한 대안

`match` 표현식은 유용하지만 원시적임  
이를 `Result<T, E>`내의 클로저를 사용하는 메서드를 통해 `match`보다 간결하게 만들 수 있음

- [`unwrap_or_else`](https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or_else) 메서드와 클로저를 사용한 예제를  [`src/example/result.rs`](./src/example/result.rs)의 `file_open_match_by_unwrap` 함수에 작성
- `match` 표현식을 전혀 사용하지 않고 완벽히 똑같게 동작함
- 더 깔끔하게 읽힐 수 있음

### 에러 발생 시 패닉을 위한 숏컷: `unwrap`과 `expect`

`match`의 사용은 충분히 잘 동작하지만, 살짝 장황하기도 하고 의도를 항상 잘 전달하는 것도 아님  
`Result<T, E>` 타입은 다양한 특정 작업을 수행하기 위해 정의된 수많은 도우미 메서드를 가지고 있음  

#### `unwrap` 메서드

`unwrap`은 패닉 발생 시 `panic!`의 기본 메시지가 출력됨

#### `expect` 메서드

`unwrap` 대신 `expect`를 이용하고 좋은 에러 메시지를 제공하면 의도를 전달하면서 패닉의 근원을 추적하는걸 쉽게 해줌  

> 프로덕션급 품질의 코드에서 대부분의 러스타시안은 `unwrap`보다 `expect`를 선택하여 해당 연산이 항시 성공한다고 기대하는 이유에 대한 더 많은 맥락을 제공함  
> 이렇게 하면 가정이 틀렸다는 것이 입증될 경우 디버깅에 사용할 더 많은 정보를 확보할 수 있음

### 에러 전파하기

- 에러 전파(propagating): 함수의 구현체에서 실패할 수도 있는 무언가를 호출할 때, 이 함수에서 에러를 처리하는 대신 **호출하는 코드 쪽으로 에러를 반환하여 그쪽에서 수행할 작업을 결정**하도록 하는 것

호출하는 코드 쪽에 더 많은 제어권을 주는 것인데, 호출하는 코드 쪽에는 에러를 어떻게 처리해야 하는지 결정하는 정보와 로직이 에러가 발생한 코드 컨텍스트 내에서 활용할 수 있는 것보다 더 많이 있을 수도 있기 때문

### 에러를 전파하기 위한 숏컷: ?

`Rust`에서는 에러를 전파하는 패턴이 너무 흔하여 이를 더 쉽게 해주는 물음표 연산자 `?`를 제공

`?` 연산자는 `Result` 값을 다루기 위해 정의했던 `match` 표현식과 거의 같은 방식으로 동작하게끔 정의되어 있음  
만일 `Result`의 값이 `Ok`라면 `Ok`안의 값이 얻어지고 프로그램이 지속됨  
만일 `Result`의 값이 `Err`라면 `return` 키워드로 에러 값을 호출하는 코드에게 전파하는 것처럼 `Err`의 값이 반환

`match` 표현식과 `?` 연산자의 차이점은 `?` 연산자를 사용할 때의 에러 값들은 `from` 함수를 거친다는 것  

> `from` 함수는 표준 라이브러리 내의 `From` 트레잇에 정의되어 있으며 어떤 값의 타입을 다른 타입으로 변환하는 데에 사용  

`?` 연산자가 `from` 함수를 호출하면, `?` 연산자가 얻게 되는 에러를 `?` 연산자가 사용된 현재 함수의 반환 타입에 정의된 에러 타입으로 변환  
이는 어떤 함수가 다양한 종류의 에러로 인해 실패할 수 있지만, **모든 에러를 하나의 에러 타입으로 반환**할 때 유용  
이를 통해 어떤 다른 에러를 하나의 커스텀 에러 타입으로 변환하여 반환하도록 할 수 있음

`?`는 많은 양의 보일러 플레이트를 제거해주고 함수의 구현을 더 단순하게 만들어줌  
`?` 뒤에 바로 메서드 호출을 연결할 수도 있음

### `?` 연산자가 사용될 수 있는 곳

`?`는 `?`이 사용된 값과 호환 가능한 반환 타입을 가진 함수에서만 사용할 수 있음  
이는 `?` 연산자가 `match` 표현식과 동일한 방식으로 함수를 일찍 끝내면서 값을 반환하는 동작을 수행하도록 정의되어 있기 때문

**함수의 반환 타입이 `Result`, `Option`, `FromResidual`을 구현한 타입**일 때 사용 가능

`Result`를 반환하는 함수에서는 `Result`에서 `?` 연산자를 사용할 수 있고, `Option`을 반환하는 함수에서는 `Option`에 대해 `?` 연산자를 사용할 수 있지만, 이를 섞어서 사용할 수는 없음  
그렇게 하려는 경우에는 `Result`의 `Ok` 메서드 혹은 `Option`의 `ok_or` 메서드 같은 것을 통해 명식적으로 변환을 할 수 있음

`main` 함수는 실행 프로그램의 시작점이자 종료점이기 때문에 특별하며, 기본적으로 `()`를 반환하는 등의 제약 사항이 있음  
`main` 함수는 반환 타입을 `Result<(), E>`로 설정할 수 있음  
`main` 함수가 `Result<(), E>`를 반환하게 되면, 실행 파일은 `main`이 `Ok(())`를 반환할 경우 `0` 값으로 종료되고, `main`이 `Err` 값을 반환할 경우 `0`이 아닌 값으로 종료됨

> `C`로 작성된 실행 파일은 종료될 때 정숫값을 반환함  
> 성공적으로 종료된 프로그램은 정수 `0`을 반환하고 에러가 발생한 프로그램은 `0`이 아닌 어떤 정숫값을 반환함

`main` 함수가 `std::process::Termination` 트레잇을 구현한 타입을 반환할 수도 있는데, 이는 `ExitCode`를 반환하는 `report`라는 함수를 가지고 있음

### [`Result` 관련 코드](./src/example/result.rs)

---

## 9.3 `panic!`이냐 `panic!`이 아니냐, 그것이 문제로다

코드가 패닉을 일으킬 때는 복구할 방법이 없음  
복구 가능한 방법이 있든 없든 간에 에러 상황에 대해 `panic!`을 호출할 수는 있지만, 그렇게 되면 호출하는 코드를 대신하여 현 상황은 복구 불가능한 것이라고 결정을 내리는 꼴

`Result` 값을 반환하는 선택을 한다면 호출하는 쪽에 옵션을 제공하는 것  
호출하는 코드 쪽에서는 상황에 적합한 방식으로 복구를 시도할 수도 있고, 현재 상황의 `Err`는 복구 불가능하다고 결론을 내리고 `panic!`을 호출하여 복구 가능한 에러를 복구 불가능한 것으로 바꿔놓을 수도 있음  
그러므로 실패할지도 모르는 함수를 정의할 때는 기본적으로 `Result`를 반환하는 것이 좋은 선택

> 예제, 프로토타입, 테스트 같은 상황에서는 `Result`를 반환하는 대신 패닉을 일으키는 코드가 더 적절함

### 예제, 프로토타입 코드, 그리고 테스트

어떠한 개념을 묘사하기 위한 예제를 작성 중이라면, 견고한 에러 처리 코드를 포함시키는 것이 오히려 예제의 명확성을 떨어트릴 수도 있음  
`unwrap` 같은 메서드의 호출이 애플리케이션의 에러 처리가 필요한 곳을 뜻하는 방식으로 해석될 수 있는데, 이러한 에러 처리는 코드의 나머지 부분이 하는 일에 따라 달라질 수 있음

어떻게 에러를 처리할지 결정할 준비가 되기 전이라면, `unwrap`과 `expect` 메서드가 **프로토타이핑할 때 매우 편리**함  
이 함수들은 코드를 더 견고하게 만들 준비가 되었을 때를 위해서 명확한 표시를 남겨둠

테스트 내에서 메서드의 호출이 실패한다면, 해당 메서드가 테스트 중인 기능이 아니더라도 전체 테스트를 실패시키도록 함  
`panic!`이 **테스트의 실패를 표시하는 방식**이므로, `unwrap`이나 `expect`의 호출이 정확히 그렇게 만들어줌

### 여러분이 컴파일러보다 더 많은 정보를 가지고 있을 때

`Result`가 `Ok` 값을 가지고 있을 거라 확신할만한 논리적 근거가 있지만, 컴파일러가 그 논리를 이해할 수 없는 경우라면, `unwrap` 혹은 `expect`를 호출하는 것이 적절할 수 있음  
어떤 연산이든 간에 특정한 상황에서는 논리적으로 불가능할지라도 기본적으로는 실패할 가능성을 가지고 있는 코드를 호출하는 것이므로, 처리가 필요한 `Result` 값이 나오게 됨  
손수 코드를 조사하여 `Err` 배리언트가 나올리 없음을 확신할 수 있다면 `unwrap`을 호출해도 아무런 문제가 없으며, **`expect`의 문구에 `Err` 배리언트가 있으면 안될 이유를 적어주는 것**이 더 좋을 것

```rust
use std::net::IpAddr;

fn main() {
    let home: IpAdd = "127.0.0.1"
        .parse()
        .expect("Hardcoded IP address should be valid");
        // expect에 이 IP` 주소가 하드코딩 되었다는 가정을 언급하는 것은
        // 향후 IP 주소가 다른 곳으로부터 가져올 필요가 생길 경우 expect를 더 나은 에러 처리 코드로 수정하도록 재촉할 것
}
```

### 에러 처리를 위한 가이드라인

코드가 결국 **나쁜 상태**에 처하게 될 가능성이 있을 때는 코드에 `panic!`을 넣는 것이 바람직함

> 나쁜 상태: 어떤 가정, 보장, 계약, 혹은 불변성이 깨질 때를 뜻하는 것  
> 유효하지 않은 값이나 모순되는 값, 혹은 찾을 수 없는 값이 코드에 전달되는 경우
> 
> - 이 나쁜 상태라는 것은 예기치 못한 무언가이며, 이는 사용자가 입력한 데이터가 잘못된 형식이라던가 하는 흔히 발생할 수 있는 것과는 반대되는 것
> - 그 시점 이후의 코드는 매번 해당 문제에 대한 검사를 하는 것이 아니라, 이 나쁜 상태에 있지 않아야만 할 필요가 있음

코드를 호출하고 타당하지 않은 값을 집어넣었다면, 가능한 에러를 반환하여 라이브러리의 **사용자들이 이러한 경우에 대해 어떤 동작을 원하는지 결정할 수 있도록 하는 것**이 가장 좋음  
그러나 계속 실행하는 것이 보안상 좋지 않거나 해를 끼치는 경우라면 `panic!`을 써서 여러분의 라이브러리를 사용하고 있는 사람에게 자신의 **코드에 있는 버그를 알려줘서 개발 중에 이를 고칠 수 있게끔 하는 것이 최선책**일 수도 있음  
**제어권에서 벗어난 외부 코드를 호출**하고 있고, 이것을 고칠 방법이 없는 **유효하지 않은 상태를 반환**한다면 `panic!`이 종종 적절함

하지만 실패가 충분히 예상되는 경우라면 `panic!`을 호출하는 것보다 `Result`를 반환하는 것이 여전히 더 적절함  

> 잘못된 데이터가 제공된 파서나, 속도 제한에 도달했음을 나타내는 상태를 반환하는 `HTTP` 요청 등

`Result`를 반환하면 **호출자가 처리 방법을 결정해야 하는 실패 가능성이 예상된다는 것**을 나타냄

코드가 유효하지 않은 값에 대해 호출되면 사용자를 위험에 빠뜨릴 수 있는 연산을 수행할 때, 그 코드는 해당 값이 유효한지를 먼저 검사하고, 만일 그렇지 않다면 `panic!`을 호출해야 함(주로 보안 상의 이유)  
유효하지 않은 데이터에 어떤 연산을 시도하는 것은 **코드를 취약점에 노출시킬 수 있음**(범위를 벗어난 메모리 접근을 시도했을 경우 표준 라이브러리가 `panic!`을 호출하는 이유: 현재 사용하는 데이터 구조가 소유하지 않은 메모리에 접근 시도하는 것은 흔한 보안 문제)

함수에는 **입력이 특정 요구사항을 만족시킬 경우에만 함수의 행동이 보장되는 계약**이 있는데, 이 **계약을 위반했을 때는 패닉**을 발생시키는 것이 이치에 맞음  
계약 위반이 항상 호출자 쪽의 버그임을 나타내고, 이는 호출하는 코드가 명시적으로 처리해야 하는 종류의 버그가 아니기 때문  
-> 함수에 대한 계약은 `API` 문서에 명시되어 있음 -> 호출하는 프로그래머가 그 코드를 고칠 필요가 있음 

`Rust`의 타입 시스템은 이러한 수많은 에러 검사를 수행해줄 수 있음  
함수에 특정한 타입의 매개변수가 있는 경우 컴파일러가 이미 유효한 값을 확인했으므로 코드 로직을 계속 진행할 수 있음  
만약 `Option`이 아닌 어떤 타입을 갖고 있다면, 여러분의 프로그램은 '아무 것도 아닌 것이 아닌 무언가'를 갖고 있음을 예측함  
그러면 코드는 `Some`과 `None` 배리언트에 대한 두 경우를 처리하지 않아도 됨

### 유효성을 위한 커스텀 타입 생성하기

사용자에게 1부터 100 사이의 숫자를 추측하도록 요청할 때, 그 숫자가 유효한지 확인하는 코드

```rust
fn main() {
    loop {
        // --snip--
        
        let guess: i32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };
        
        if guess < 1 || guess > 100 {
            println!("The secret number will be between 1 and 100.");
            continue;
        }
        
        match guess.cmp(&secret_number) {
            // --snip--
        }
    }
}
```

이는 이상적인 해결책이 아님, 만약 이러한 요구사항이 여러 개일 때, 모든 함수 내에서 이런 검사를 하는 것은 **지루한 일이며 성능에 영향**을 줄 수 있음

그대신 새로운 타입을 만들고 그 타입의 인스턴스를 생성하는 함수에서 유효성을 확인하는 방식으로 유효성 확인을 모든 곳에서 반복하지 않게 할 수 있음  
이렇게 하면 함수가 새로운 타입을 시그니처에 사용하여 받은 값을 자신있게 사용할 수 있어 안전

```rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            // 이 코드를 호출하는 프로그래머에게 고쳐야 할 버그가 있음을 알려주는데, 범위 밖에 `value`로 `Guess`를 생성하는 것은 `Guess::new`가 요규하는 계약을 위반하기 때문
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }
        
        Guess { value }
    }
    
    // Getter
    pub fn value(&self) -> i32 {
        // 외부에서 직접 설정할 수 없게 하기 위해 `value`를 `private`으로 설정하고 읽기 권한만 줌
        self.value
    }
}

```

### 정리

`Rust`의 에러 처리 기능은 더 견고한 코드를 작성하는 데 도움을 주도록 설계됨

- `panic!` 매크로
  - 프로그램이 처리 불가능한 상태에 놓여 있음에 대한 신호를 주고 유효하지 않거나 잘못된 값으로 계속 진행을 시도하는 대신 실행을 멈추게끔 해줌
- `Result` 열거형
  - 복구할 수 있는 방법으로 코드의 연산이 실패할 수도 있음을 알려줌
  - 코드를 호출하는 코드에게 잠재적인 성공이나 실패를 처리해야 할 필요가 있음을 알려줄 수 있음

`panic!`이나 `Result`를 적절한 상황에서 사용하는 것은 코드가 불가피한 문제에 직면했을 때도 더 신뢰할 수 있도록 해줌