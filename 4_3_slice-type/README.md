# The Slice Type

- 슬라이스를 사용하면 전체 컬렉션이 아닌, 컬렉션의 연속적인 요소 시퀀스를 참조할 수 있습니다.
- 슬라이스는 참조이기 때문에 소유권이 없습니다.

### 문제 1

- Q: 공백으로 구분된 단어 문자열을 사용하고 해당 문자열에서 찾은 첫 번째 단어를 반환하는 함수를 작성하세요.
  - 함수가 문자열에서 공백을 찾지 못하면 전체 문자열이 한 단어이므로 전체 문자열이 반환됩니다.

- 함수의 시그니처는 다음과 같이 작성할 수 있습니다.

  ```rust
  fn first_word(s: &String) -> Things {}
  ```
  
- 임의로 함수를 구현해보도록 하겠습니다.

  ```rust
  fn first_word(s: &String) -> usize {
      let bytes = s.as_bytes(); // 문자열을 바이트의 배열로 변환합니다.
  
      for (i, &item) in bytes.iter().enumerate() {
          // 바이트 배열에 대한 반복자를 만듭니다.
          // `enumerate` 메서드가 튜플을 반환하기 때문에 튜플을 분해할 수 있습니다.
          if item == b' ' {
              return i;
          }
      }
  
      s.len()
  }
  
  fn main() {
    let mut s = String::from("hello world");
    let word = first_word(&s);
    s.clear(); // 문자열을 비웁니다.
  }
  ```

- 위처럼 코드를 작성했을 경우, `word` 값에 `s`가 전혀 연결이 되어 있지 않기 때문에 `word`의 값이 변경되어도 `5`를 저장하고 있습니다.
- 저장한 이후로 내용이 변경되었기 때문에 이러한 동작은 버그가 될 수 있습니다.
- 그렇다고 아래와 같이 함수 시그니처를 구성하면 불필요한 변수가 너무 많이 선언됩니다.

  ```rust
  fn second_word(s: &String) -> (usize, usize) {}
  ```
  
## String slice

```rust
let s = String::from("hello world");

let hello = &s[0..5]; // 0부터 시작하려는 경우 &s[..5]와 같이 작성할 수 있습니다.
let world = &s[6..11]; // 마찬가지로 마지막 인덱스로 종료하려는 경우 &s[6..]와 같이 작성할 수 있습니다.
```

- `String`의 일부를 참조하는 것을 `string slice`라고 합니다.
- `&str` 키워드를 사용해 `String slice` 타입을 나타냅니다.
- `String slice`는 `String`의 일부를 참조하기 때문에 소유권을 갖지 않습니다.

## 문자열 리터럴

- 바이너리 내부에 저장되는 문자열 리터럴은 `string slice` 타입을 갖습니다.
- 문자열 슬라이스가 있으면 직접 전달할 수 있고 참조를 전달할 수도 있습니다.
- `a`에 대한 참조 대신 문자열 슬라이스를 사용하도록 함수를 정의하면 `String` 기능 손실 없이 `API`가 더 일반적이고 유용해집니다.

## 다른 타입의 슬라이스

- 배열에서도 슬라이스가 가능합니다.

```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3];
```

- `slice`는 `[i32]` 타입입니다.
- 스트링 슬라이스와 동일한 방식으로 작동합니다.

## 요약

- 소유권, 차용 및 슬라이스의 개념은 컴파일 타입에 `Rust` 프로그램의 메모리 안전을 보장합니다.