# 10. 제네릭 타입, 트레잇, 라이프타임

모든 프로그래밍 언어는 중복되는 개념을 효율적으로 처리하기 위한 도구를 가지고 있음

`Rust`에서는 제네릭(generic)이 그 역할을 맡는데, **제네릭은 구체(concrete) 타입 혹은 기타 속성에 대한 추상화된 대역**  
컴파일과 실행 시점에 제네릭들이 **무슨 타입으로 채워지는지 알 필요 없이** 제네릭의 동작이나 다른 제네릭과의 관계를 표현할 수 있음

### 함수를 추출하여 중복 없애기

제네릭은 여러 가지 타입을 나타내는 자리표시자의 위치에 특정 타입을 집어넣는 것으로 코드 중복을 제거할 수 있게 해줌

### [개요 관련 코드](./src/main.rs)

## 10.1 제네릭 데이터 타입

제네릭을 사용하면 함수 시그니처나 구조체의 아이템에 다양한 구체적 데이터 타입을 사용할 수 있도록 정의할 수 있음

### 제네릭 함수 정의

함수 시그니처 내 매개변수와 반환 값의 데이터 타입 위치에 제네릭을 사용함

```rust
fn largest<T>(list: &[T]) -> T { list[0] }
```

### 제네릭 구조체 정의

문법은 구조체 이름 바로 뒤 꺾쇠 괄호에 타입 매개변수 이름을 선언하고, 구조체 정의 내 구체적 데이터 타입을 지정하던 곳에 제네릭 타입을 대신 사용

```rust
struct Point<T> {
    x: T,
    y: T,
}
```

제네릭 타입 매개변수는 원하는 만큼 여러 개를 정의할 수 있지만, 많으면 많아질수록 코드 가독성은 떨어짐  
만약 코드에서 **많은 수의 제네릭 타입이 필요함**을 알게 되었다면, **코드를 리팩터링해서 작은 부분들로 나누는 것을 고려**해야 할 수도 있음

### 제네릭 열거형 정의

구조체처럼 열거형도 배리언트에 제네릭 데이터 타입을 갖도록 정의할 수 있음

```rust
enum Option<T> {
    Some(T),
    None,
}
```

`Option<T>` 열거형은 `T` 타입에 대한 제네릭이며, `T` 타입을 들고 있는 `Some` 배리언트와 아무런 값도 들고 있지 않은 `None` 배리언트를 가짐

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

작성한 코드에서 보유하는 값의 타입만 다른 구조체나 열거형이 여러 개 있음을 발견했을 때는 제네릭 타입을 사용해 코드 중복을 제거할 수 있음

### 제네릭 메서드 정의

구조체 정의에서 사용한 제네릭 타입 매개변수와, 구조체의 메서드 시그니처 내에서 사용하는 제네릭 타입 매개변수가 항상 같은 것은 아님

### 제네릭 코드의 성능

제네릭 타입의 사용이 구체적인 타입을 사용했을 때와 비교해서 **전혀 느려지지 않음**

`Rust`는 컴파일 타임에 **제네릭을 사용하는 코드를 단형성화**함

> 단형성화(monomorphization): 제네릭 코드를 실제 구체 타입으로 채워진 특정한 코드로 바꾸는 과정  
> 이 과정에서, 컴파일러는 제네릭 함수를 만들 때 거친 과정을 정반대로 수행  
> 즉, 컴파일러는 제네릭 코드가 호출된 곳을 전부 찾고, 제네릭 코드가 호출할 때 사용된 구체 타입으로 코드를 생성

#### 단형성화 예제


- 단형성화 전 코드
  ```rust
  fn main() {
      let integer = Some(5);
      let float = Some(5.0);
  }
  ```
- 단형성화 후 코드
  ```rust
  enum Option_i32 {
    Some(i32),
    None,
  }
  enum Option_f64 {
    Some(f64),
    None,
  }
  fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
  }
  ```

제네릭 `Option<T>`가 컴파일러에 의해 특정한 정의들로 대체되었음  
`Rust` 컴파일러가 제네릭 코드를 각 인스턴스의 명시적인 타입으로 변경해주는 덕분에, 굳이 런타임 비용을 줄이기 위해 수동으로 직접 각 타입마다 중복된 코드를 작성할 필요가 없음

> 단형성화 과정은 `Rust` 제네릭을 런타임에 극도로 효율적으로 만들어줌


### [제네릭 관련 코드](./src/example/generic.rs)

---

## 10.2 트레잇으로 공통된 동작을 정의하기 

> **트레잇(trait): 특정한 타입을 가지고 있으면서 다른 타입과 공유할 수 있는 기능을 정의**

트레잇을 사용하면 공통된 기능을 추상적으로 정의할 수 있음  
트레잇 바운드(trait bound)를 이용하면 어떤 제네릭 타입 자리에 특정한 동작을 갖춘 타입이 올 수 있음을 명시

> 다른 언어에서 흔히 인터페이스(`interface`)라고 부르는 기능과 유사

### 트레잇 정의하기

**타입의 동작은 해당 타입에서 호출할 수 있는 메서드로 구성**  
만약에 다양한 타입에서 동일한 메서드를 호출할 수 있다면, 이 타입들은 **동일한 동작을 공유**한다고 표현 가능  
트레잇 정의는 메서드 시그니처를 그룹화하여 특정 목적을 달성하는 데 필요한 일련의 동작을 정의하는 것

트레잇은 본문에 여러 메서드를 가질 수 있음  
메서드 시그니처는 한 줄에 하나씩 나열되며, 각 줄은 세미콜론으로 끝남

### 특정 타입에 트레잇 구현하기

어떤 타입에 대한 트레잇을 구현하는 것은 평범한 메서드를 구현하는 것과 비슷함  
다른 점은 `impl` 뒤에 구현하고자 하는 트레잇의 이름을 적고, 그다음 `for` 키워드와 트레잇을 구현할 타입을 명시한다는 점

`impl` 블록 안에서 트레잇에 정의된 메서드 시그니처를 집어넣되, 구현하고자 하는 동작을 채워 넣음

이렇게 트레잇을 구현한 구조체는 보통의 메서드를 호출하는 것과 같은 방식으로 트레잇 메서드를 호출할 수 있음

> 유일한 차이점은 **크레이트 사용자가 타입 뿐만 아니라 트레잇도 스코프로 가져와야 한다**는 점

트레잇을 사용하기 위해서는 사용할 크레이트에 의존적은 다른 크레이트들 또한 스코프로 가져와서 자신들의 타입에 대해 구현할 수 있음

#### 트레잇 구현의 제약사항

트레잇이나 트레잇을 구현할 타입 중 둘 중 하나는 반드시 **자신의 크레이트 것이어야 해당 타입에 대한 트레잇을 구현**할 수 있음

> 우리가 만든 크레이트의 일부 기능으로 표준 라이브러리 트레잇인 `Display` 등을 구현할 수 있음  
> 그러나, 우리가 만든 크레이트에서는 `Vec<T>`에 대한 `Display` 트레잇을 구현할 수 없음
> 
> 이 제약은 프로그램의 특성 중 하나인 **일관성(coherence)**, 보다 자세히는 **고아 규칙(orphan rule)**에서 나옴  
> 이 규칙으로 인해 **다른 사람의 코드가 자신의 코드를 망가뜨릴 수 없으며**, 반대도 마찬가지  
> 이 규칙이 없다면 두 크레이트가 동일한 타입에 동일한 트레잇을 구현할 수 있게 되고, `Rust`는 어떤 구현체를 이용해야 할지 알 수 없게 됨

### 기본 구현

타입에 트레잇을 구현할 때마다 모든 메서드를 구현할 필요는 없도록 트레잇의 **메서드에 기본 동작을 제공**할 수도 있음  
이러면 특정한 타입에 트레잇을 구현할 때 기본 동작을 유지할지 혹은 오버라이드 할지 선택할 수 있음

> 어떤 메서드를 오버라이딩하는 구현을 하면 해당 메서드의 기본 구현을 호출할 수 없음

### 매개변수로서의 트레잇

#### 트레잇 바운드 문법

**트레잇 바운드(trait bound)**는 `impl trait` 문법과 같은 좀더 기다란 형식의 문법적 설탕  
트레잇 바운드는 아래와 같이 생김

```rust
pub fn notify<T: Summary>(item: &T) {
  println!("Breaking news! {}", item.summarize());
}
```

트레잇 바운드는 꺾쇠 괄호 안의 제네릭 타입 매개변수 선언에 붙은 콜론(`:`) 뒤에 위치함

`impl trait` 문법이 단순한 상황에서는 편리하고 코드를 더 간결하게 만들어주는 반면, 트레잇 바운드 문법은 더 복잡한 상황을 표현할 수 있음  

```rust
pub fn notify(item1: &impl Summary, item2: &impl Summary) {}
```

만약 위에서 서로 다른 타입이어도 상관없다면 `impl trait` 문법 사용도 적절함

```rust
pub fn notify<T: Summary>(item1: &T, item2: &T) {}
```

하지만 두 매개변수가 같은 타입으로 강제되어야 한다면 위처럼 사용해야 함  
매개변수의 타입으로 지정된 제네릭 타입 `T`는 함수를 호출할 때 `item1`, `item2` 인수 값의 구체적인 타입이 반드시 동일하도록 제한

#### `+` 구문으로 트레잇 바운드를 여럿 지정하기

**트레잇 바운드는 여러 개 지정될 수 있음**  

```rust
// pub fn notify(item: &(impl Summary + Display)) {}
pub fn notify<T: Summary + Display>(item: &T) {}
```

두 개의 트레잇 바운드가 지정됐으니, `notify` 본문에서는 `item`의 `summarize` 메서드를 호출할 수도 있고 `item`을 `{}`로 포맷팅할 수도 있음

#### `where` 조항으로 트레잇 바운드 정리하기

트레잇 바운드가 너무 많아지면 문제가 생김  
제네릭마다 트레잇 바운드를 갖게 되면, 여러 제네릭 타입 매개변수를 사용하는 함수는 함수명과 매개변수 사이에 너무 많은 트레잇 바운드 정보를 담게 될 가능성이 있음

```rust
// fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {}
fn some_function<T, U>(t: &T, u: &U) -> i32
  where T: Display + Clone,
        U: Clone + Debug
{}
```

트레잇 바운드로 도배되지 않고, 평범한 함수처럼 함수명과 매개변수 목록, 반환 타입이 붙어 있으니, 함수 시그니처를 읽기 쉬워짐

### 트레잇을 구현하는 타입을 반환하기

`impl trait` 문법을 반환 타입 위치에 써서 어떤 트레잇을 구현한 타입의 값을 반환시키는 데에도 사용 가능

### 트레잇 바운드를 사용해 조건부로 메서드 구현하기

제네릭 타입 매개변수를 사용하는 `impl` 블록에 트레잇 바운드를 이용하면, **지정된 트레잇을 구현하는 타입에 대해서만 메서드를 구현**할 수도 있음

타입이 특정 트레잇을 구현하는 경우에만 해당 타입에 트레잇을 구현할 수도 있음  
트레잇 바운드를 만족하는 **모든 타입에 대해 트레잇을 구현하는 것을 포괄 구현(blanket implementations)**이라 하며, `Rust` 표준 라이브러리 내에서 광범위하게 사용 중

```rust
impl<T: Display> ToString for T {
  // --snip--
}
```

`Display` 트레잇이 구현된 거의 모든 타입에서 `to_string()` 메서드를 호출할 수 있는건 표준 라이브러리의 이 포괄 구현 덕분

```rust
fn main() {
    let s = 3.to_string();
}
```

> 트레잇과 트레잇 바운드를 사용하면 제네릭 타입 매개변수로 코드 중복을 제거하면서 특정 동작을 하는 제네릭 타입이 필요하다는 사실을 컴파일러에게 전달할 수 있음  
> 컴파일러는 트레잇 바운드를 이용하여 코드에 사용된 구체적인 타입들이 올바른 동작을 제공하는지 검사  
> 동작 타입 언어에서는 이런 경우 런타임 에러 발생  
> `Rust`는 **컴파일 시점에 에러를 발생시켜 코드를 실행하기도 전에 문제를 해결**하도록 강제
> 
> 따라서 런타임에 해당 동작을 구현하는지 검사하는 코드를 작성할 필요가 없음  
> `Rust`는 **제네릭의 유연성과 성능 둘 다 놓치지 않음**

---

## 10.3 라이프타임으로 참조자의 유효성 검증하기

**라이프타임(lifetime)**은 이미 사용해 본 적 있는 또 다른 종류의 제네릭  
라이프타임은 어떤 타입이 원하는 동작이 구현되어 있음을 보장하기 위한 것이 아니라, 어떤 참조자가 필요한 기간 동안 유효함을 보장하도록 함

`Rust`의 모든 참조자는 라이프타임이라는 참조자의 유효성을 보장하는 범위를 가짐  
타입 추론과 같이 라이프타임도 암묵적으로 추론됨  
하지만 참조자의 수명이 여러 방식으로 서로 연관될 수 있는 경우에는 라이프타임을 명시해 주어야 함  
`Rust`에서 런타임에 사용되는 실제 참조자가 반드시 유효할 것임을 보장하려면 제네릭 라이프타임 매개변수로 이 관계를 명시해야 함

### 라이프타임으로 댕글링 참조자 방지하기

라이프타임의 주 목적은 **댕글링 참조자(dangling reference)** 방지

> 댕글링 참조자는 프로그램이 참조하려고 한 데이터가 아닌 엉뚱한 데이터를 참조하게 되는 원인일 수 있음

스코프가 클 수록 더 오래 산다(lives longer)고 표현함  
`Rust`가 댕글링 참조자를 방지하기 위해 코드가 유효한지 '빌림 검사기'를 통해 검사함

### 빌림 검사기

`Rust` 컴파일러는 **빌림 검사기**(borrow checker)로 스코프를 비교하여 빌림의 유효성을 판단

```rust
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          |
}                         // ---------+
```

- `r`의 라이프타임은 `'a`, `x`의 라이프타임은 `'b`로 표현
- `'b` 블록은 `'a` 블록보다 작음
- `Rust는 컴파일 타임에 두 라이프타임의 크기를 비교하고, `'a` 라이프타임을 갖는 `r`이 `'b` 라이프타임을 갖는 메모리를 참조하고 있음을 인지
- 즉, 참조 대상이 참조자보다 오래 살지 못하니 `Rust` 컴파일러는 이 프로그램을 컴파일하지 않음

```rust
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       |
                          // --+       |
}                         // ----------+
```

- 여기서는 `x`의 라이프타임이 `r`보다 더 김
- 참조자 `r`이 유효한 동안에 `x`도 유효하다는 것을 알고 있으므로 `r`은 `x`를 참조 가능

### 함수에서의 제네릭 라이프타임

특수한 경우(참조자를 입력받아 참조자를 반환하는)에, `Rust` 컴파일러는 어떤 참조자가 반환되는지 알 수 없음  
따라서 전달받은 참조자의 구체적인 라이프타임도 알 수 없게 됨  
즉, 스코프를 살펴보는 것만으로는 반환할 참조자의 유효성을 보장할 수 없음

> 참조자 간의 관계를 제네릭 라이프타임 매개변수로 정의하여 빌림 검사기가 분석할 수 있도록 해야 함

### 라이프타임 명시 문법

라이프타임을 명시한다고 해서 참조자의 수명이 바뀌진 않음  
여러 참조자에 대한 수명에 영향을 주지 않으면서 서로 간 수명의 관계가 어떻게 되는지에 대해 기술하는 것  
함수에 제네릭 라이프타임 매개변수를 명시하면 어떠한 라이프타임을 갖는 참조자라도 전달 가능

라이프타임 매개변수의 이름은 어퍼스트로피(`'`)로 시작해야 하며, 매우 짧은 소문자로 정함(대부분 첫 번째 라이프타임을 명시할 때 `'a`를 사용)

```rust
&i32        // 참조자
&'a i32     // 라이프타임이 명시된 참조자
&'a mut i32 // 라이프타임이 명시된 가변 참조자
```

> 라이프타임 명시는 `Rust`에게 여러 참조자의 제네릭 라이프타임 매개변수가 서로 어떻게 연관되어 있는지 알려주는 용도

### 함수 시그니처에서 라이프타임 명시하기

함수 시그니처에서 라이프타임을 명시하기 위해서는 제네릭 타입 매개변수를 사용할 때처럼 함수명과 매개변수 목록 사이의 꺾쇠괄호 안에 제네릭 라이프타임 매개변수를 선언할 필요가 있음

함수 시그니처에 라이프타임 매개변수를 지정하면, 컴파일러는 각 매개변수가 얼마나 오래 살지는 관심 없고, 이 시그니처를 만족하는 어떤 스코프 `'a`로 대체할 수 있다는 점만 알면 됨

라이프타임 명시는 함수 시그니처의 타입들과 마찬가지로 함수에 대한 계약서의 일부  
그래서 함수 시그니처에 작성하며, 계약을 가지고 있다는 것은 `Rust` 컴파일러가 수행하는 분석이 좀 더 단순해질 수 있음을 의미

명시된 라이프타임에 대응하는 구체적인 라이프타임은 각 매개변수의 스코프가 겹치는 부분이며, 둘 중 더 작은 쪽이 구체적인 라이프타임이 됨

### 라이프타임의 측면에서 생각하기

라이프타임 매개변수 명시의 필요성은 함수가 어떻게 동작하는지에 따라서 달라짐

참조자를 반환하는 함수를 작성할 때는 반환 타입의 라이프타임 매개변수가 함수 매개변수 중 하나와 일치해야 함  
반환할 참조자가 함수 매개변수 중 하나를 참조하지 않을 유일한 경우: 함수 내부에서 생성  
함수 내부에서 생성된 값은 함수가 끝나는 시점에 스코프를 벗어나므로 댕글링 참조자가 됨

> `Rust`는 댕글링 참조자를 생성하는 코드를 눈감아주지 않음  
> 해결 방법은 참조자 대신 값의 소유권을 갖는 데이터 타입을 반환하여 함수를 호출한 함수 측에서 값을 정리하도록 하는 것

> 라이프타임 문법의 근본적인 역할은 함수의 **다양한 매개변수와 반환 값의 라이프타임을 연결하는 데에 있음  
> 한 번 라이프타임을 연결해 주고 나면, `Rust`는 해당 정보를 이용해 댕글링 포인터 생성을 방지하고, 메모리 안전 규칙을 위배하는 연산을 배제함

### 구조체 정의에서 라이프타임 명시하기

구조체가 참조자를 들고 있도록 하려면 구조체 정의 내의 **모든 참조자에 라이프타임을 명시**해야 함

### 라이프타임 생략

모든 참조자는 라이프타임을 가지며, 참조자를 사용하는 함수나 구조체는 라이프타임 매개변수를 명시해야 함

함수에 라이프타임을 명시하지 않아도 컴파일 할 수 있는 이유는 `Rust`의 역사에서 찾아볼 수 있음  
초기 버전에는 반드시 명시적인 라이프타임이 필요했음

```rust
fn first_word<'a>(s: &'a str) -> &'a str {}
```

그러나 여러 번 코드를 작성하면서, 똑같은 라이프타임 명시를 계속 똑같이 작성하고 있다는 것을 깨달음  
이 상황들은 예측 가능한 상황들이었으며, 몇 가지 결정론적인(deterministic) 패턴을 따르고 있었음  
따라서 `Rust` 팀은 컴파일러 내에 이 패턴을 프로그래밍하여, 이러한 상호아들에서는 라이프타임을 명시하지 않아도 빌림 검사기가 추론할 수 있도록 함

앞으로 더 많은 결정론적 패턴이 컴파일러에 추가될 가능성이 있으므로, 나중에는 라이프타임 명시가 필요한 상황이 더욱 적어질 수 있음

`Rust`의 참조자 분석 기능에 프로그래밍 된 이 패턴들을 **라이프타임 생략 규칙**(lifetime elision rules)라고 부름

생략 규칙은 완전한 추론 기능을 제공하는 것이 아니므로, 추측 대신 에러를 발생시켜서 라이프타임 명시를 요구할 것임

- 입력 라이프타임(input lifetime): 함수나 메서드 매개변수의 라이프타임
- 출력 라이프타임(output lifetime): 반환 값의 라이프타임

라이프타임 명시가 없을 때 컴파일러가 참조자의 라이프타임을 알아내는 데 사용하는 규칙

1. 컴파일러가 참조자인 매개변수 각각에게 라이프타임 매개변수를 할당함(입력 라이프타임에 적용)
2. 만약 입력 라이프타임 매개변수가 딱 하나라면, 해당 라이프타임이 모든 출력 라이프타임에 대입
3. 만약 입력 라이프타임 매개변수가 여러 개인데, 그중 하나가 `&self`나 `&mut self`라면(메서드라면), `self`의 라이프타임이 모든 출력 라이프타임 매개변수에 대입

세 가지 규칙을 모두 적용했는데도 반환 타입의 라이프타임을 **알아내지 못했다면 컴파일 에러가 발생**함(생략 규칙이 실패함)

### 메서드 정의에서 라이프타임 명시하기

문법은 제네릭 타입 매개변수 문법과 같음  
라이프타임 매개변수의 선언 및 사용 위치는 구조체 필드나 메서드 매개변수 및 반환 값과 연관이 있느냐 없느냐에 따라 달라짐

라이프타임이 구조체 타입의 일부가 되기 때문에, 구조체 필드의 라이프타임 이름은 `impl` 키워드 뒤에 선언한 다음 구조체 이름 뒤에 사용해야 함

`impl` 블록 안에 있는 메서드 시그니처의 참조자들은 구조체 필드에 있는 참조자의 라이프타임과 관련되어 있을 수도 있고 독립적일 수도 있음

### 정적 라이프타임

**정적 라이프타임**(static lifetime)은 해당 참조자가 프로그램의 전체 생애주기 동안 살아있음을 의미함  
모든 문자열 리터럴은 `'static` 라이프타임을 가짐

```rust
fn main() {
    let s: &'static str = "I have a static lifetime.";
}
```

문자열의 텍스트 프로그램의 바이너리 내에 직접 저장되기 때문에 언제나 이용 가능

`'static` 라이프타임을 이용하라는 제안이 담긴 에러메시지를 보고나면, 바로 `'static` 라이프타임으로 지정하기 보단, 해당 참조자가 반드시 프로그램의 전체 라이프타임동안 유지되어야만 하는 참조자인지 고민해보아야 함

`'static` 라이프타임을 제안하는 에러 메시지는 대부분의 경우 댕글링 참조자를 만들다가 발생하거나, 사용 가능한 라이프타임이 잘못 짝지어져서 발생함

> 이러한 경우 바람직한 해결책은 **그런 문제를 고치는 것이지, `'static` 라이프타임이 아님**

### 제네릭 타입 매개변수, 트레잇 바운드, 라이프타임을 한 곳에서 사용해 보기

```rust
use std::fmt::Display;

// 라이프타임은 제네릭의 일종이므로 함수명 뒤의 꺾쇠 괄호 안에는
// 라이프타임 매개변수 `'a` 선언과 제네릭 타입 매개변수 `T`가 함께 나열되어 있음
fn longest_with_an_announcement<'a, T> (
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

### 정리

- 제네릭 타입 매개변수, 트레잇, 트레잇 바운드, 제네릭 라이프타임 매개변수를 통해 다양한 상황에 맞게 작동하는 코드를 중복 없이 작성할 수 있음
  - 제네릭 타입 매개변수: 다양한 타입으로 작동하는 코드 작성 가능
  - 트레잇과 트레잇 바운드: 제네릭 타입을 다루면서도 코드에 필요한 특정 동작을 보장
  - 라이프타임: 유연한 코드를 작성하면서도 댕글링 참조자가 발생할 일이 없음
- 이 모든 것들은 컴파일 타임에 분석되어 런타임 성능에 전혀 영향을 주지 않음 

### [라이프타임 관련 코드](./src/example/lifetime.rs)
