# `mod`와 파일 시스템

```bash
cargo new communicator --lib
```
- 라이브러리 크레이트를 만들면, 다른 사람들이 자신들의 프로젝트에 디펜던시로 추가할 수 있습니다.
- 만들기 위해서는 `--bin` 플래그 대신에 `--lib` 플래그를 사용하면 됩니다.
- 이렇게 생성한 프로젝트에는 `main.rs` 파일 대신에 `lib.rs`가 생성되고, `main.rs`가 없으므로 `cargo run` 커맨드로 실행할 것이 없습니다.
- 라이브러리 크레이트는 `cargo build`를 사용하여 빌드(컴파일)합니다.

## 모듈 파일 시스템의 규칙

- 만일 `foo`라는 이름의 모듈이 서브모듈을 가지고 있지 않다면, `foo.rs`라는 이름의 파일 내에 `foo`에 대한 선언을 집어 넣어야 합니다.
- 만일 `foo`가 서브 모듈을 가지고 있다면, `foo/mod.rs`라는 이름의 파일 에 `foo`에 대한 선언을 집어 넣어야 합니다.

> 이 규칙들은 재귀적으로 적용되므로, `foo`라는 이름의 모듈이 `bar`라는 이름의 서브 모듈을 갖고 있고 `bar`는 서브 모듈이 없다면, `foo/bar.rs`, `foo/mod.rs` 파일이 있어야 합니다.
> 이 모듈들은 부모 모듈의 파일에 `mod` 키워드를 사용하여 선언되어 있어야 합니다.

## `pub`으로 가시성(visibility) 제어하기

- 모듈 내의 함수를 외부에서 사용하기 위해서는 `pub` 키워드를 통해 외부에서 사용할 것임을 명시해야 합니다.

### 비공개 규칙(Privacy Rules)

1. 만일 어떤 아이템이 공개라면, 이는 부모 모듈의 어디에서건 접근이 가능합니다.
2. 만일 어떤 아이템이 비공개라면, 같은 파일 내에 있는 부모 모듈 및 이 부모의 자식 모듈에서만 접근 가능합니다.

## 이름 가져오기

- 깊은 모듈 트리를 가지고 있다면, 모듈의 이름을 계속해서 반복해야 하는 문제가 있습니다.
- 이를 해결하기 위해 `use` 키워드를 사용하여 모듈의 이름을 가져올 수 있습니다.

### `super`를 사용하여 부모 모듈에 접근하기

- 모듈을 사용할 경로의 기준은 현재 모듈이기 때문에, 하위 모듈에서 상위 모듈의 아이템에 접근하기 위해서는 `super` 키워드를 사용해야 합니다.
- `super` 키워드는 현재 모듈의 부모 모듈을 가리킵니다.

---

