# 에러 처리

`Rust`는 에러를 복구 가능한(recoverable) 에러와 복구 불가능한(unrecoverable) 에러 두 가지 범주로 묶음

- 복구 가능한 에러
  - "파일을 찾을 수 없음" 등
  - 사용자에게 문제를 보고하고 명령을 재시도하도록 원함
- 복구 불가능한 에러
  - 잘못된 배열 인덱스 참조

대부분의 언어는 예외 처리(exception)와 같은 메커니즘을 이용하여 이 두 종류를 구분하지 않고 같은 방식으로 처리하지만, `Rust`에는 예외 기능이 없음  
대신, 복구 가능한 에러를 위한 `Result<T, E>` 타입과 복구 불가능한 에러가 발생했을 때 프로그램을 종료하는 `panic!` 매크로를 제공

## `panic!`으로 복구 불가능한 에러 처리하기

코드에서 나쁜 일이 일어나고 거기에 할 수 있는 행동이 존재하지 않을 때, `panic!` 매크로를 사용할 수 있음  

#### 패닉을 일으키는 방법

1. 잘못된 인덱스 접근과 같은 기본적으로 패닉을 일으킬 동작 발생
2. `panic!` 매크로 명시적 호출

#### 패닉의 동작

1. 실패 메시지 출력
2. 되감기(unwind)
3. 스택 청소
4. 종료

패닉이 발생했을 때 그 패닉의 근원을 쉽게 추적하기 위해 환경 변수를 통하여 `Rust`가 호출 스택을 보여주도록 할 수 있음

#### `panic!`에 대응하여 스택을 되감거나 그만두기

`panic!`이 발생하면 프로그램은 되감기(unwinding)을 시작하는데, 이는 `Rust`가 패닉을 발생시킨 각 함수로부터 스택을 거꾸로 훑어가면서 데이터를 청소한다는 뜻  
하지만 이 작업은 비용이 발생하기 때문에 데이터 정리 작업 없이 즉각 종료되는 그만두기(aborting)을 선택할 수 있음

프로그램이 사용하고 있던 메모리는 운영체제가 청소해주어야 함.  
프로젝트 내에서 결과 바이너리를 가능한 작게 만들고 싶다면, `Cargo.toml` 내에서 적합한 `[profile]` 섹션에 `panic = abort`를 추가하여 설정할 수 있음

- 릴리즈 모드에서 설정 예시
  
  ```toml
  [profile.release]
  panic = 'abort'
  ```

### `panic!` 백트레이스 이용하기

코드의 버그 때문에 라이브러리로부터 `panic!` 호출이 발생할 때 예제

`C`에서 데이터 구조의 끝을 넘어서 읽는 시도는 정의되지 않은 동작  
메모리가 해당 데이터 구조의 소유가 아닐지라도, 그 데이터 구조의 해당 요소에 상응하는 메모리 위치에 있는 모든 값을 가져올 수 있음

이러한 것을 버퍼 초과 읽기(buffer overread)라 하며, 접근이 허용되어서는 안 되는 데이터를 읽기 위해 어떤 공격자가 배열 뒤에 저장된 데이터를 읽어낼 요량으로 인덱스를 다루게 된다면, 이는 보안 취약점으로 이어질 수 있음

#### `RUST_BACKTRACE` 환경 변수

`RUST_BACKTRACE` 환경 변수를 설정하여 에러의 원인이 무엇인지 정확하게 백트레이스할 수 있음

> 백트레이스(backtrace)
> 
> 어떤 지점에 도달하기까지 호출한 모든 함수의 목록

- 백트레이스 읽는 요령
  - 위에서부터 시작하여 작성한 파일이 보일 때까지 읽는 것
  - 그 곳이 바로 문제를 일으킨 지점

- 환경변수 적용하는 방법
- `Rust` 실행 명령(`cargo run`) 앞에 환경변수 선언
  
    ```bash
    RUST_BACKTRACE=1 cargo run
    ```

> 실제 출력값은 운영체제 및 `Rust` 버전에 따라 다를 수 있음

이러한 정보로 백트레이스를 얻기 윗해서는 디버그 심볼이 활성화되어 있어야 함  
디버그 심볼은 여기처럼 `cargo build`나 `cargo run`을 `--release` 플래그 없이 실행했을 때 기본적으로 실행 됨

프로그램이 패닉에 빠지지 않도록 하려면 직접 작성한 파일이 언급된 첫 줄부터 조사해야 함  
이러한 패닉을 고칠 방법은 범위를 벗어난 벡터 인덱스로 요소를 요청하지 않도록 하는 것

### [`panic!` 관련 코드](./src/example/panic.rs)

---

## `Result`로 복구 가능한 에러 처리하기

대부분의 에러는 프로그램을 전부 중단해야 할 정도로 심각하지 않음  
함수 실패 원인은 쉽게 해석하고 대응할 수 있는 경우가 많음

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

- `T`와 `E`는 제네릭 타입 매개변수
  - `T`는 성공한 경우에 `Ok` 배리언트 안에 반환될 값의 타입
  - `E`는 실패한 경우에 `Err` 배리언트 안에 반환될 에러의 타입

> `Result`는 반환하고자 하는 성공적인 값과 에러 값이 달라질 수 있는 다양한 상황에서 대응할 수 있음

### 서로 다른 에러에 대해 매칭하기

#### `Result<T, E>`와 `match` 사용에 대한 대안

`match` 표현식은 유용하지만 원시적임  
이를 `Result<T, E>`내의 클로저를 사용하는 메서드를 통해 `match`보다 간결하게 만들 수 있음

- [`unwrap_or_else`](https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or_else) 메서드와 클로저를 사용한 예제를  [`src/example/result.rs`](./src/example/result.rs)의 `file_open_match_by_unwrap` 함수에 작성
- `match` 표현식을 전혀 사용하지 않고 완벽히 똑같게 동작함
- 더 깔끔하게 읽힐 수 있음

### 에러 발생 시 패닉을 위한 숏컷: `unwrap`과 `expect`

`match`의 사용은 충분히 잘 동작하지만, 살짝 장황하기도 하고 의도를 항상 잘 전달하는 것도 아님  
`Result<T, E>` 타입은 다양한 특정 작업을 수행하기 위해 정의된 수많은 도우미 메서드를 가지고 있음  

#### `unwrap` 메서드

`unwrap`은 패닉 발생 시 `panic!`의 기본 메시지가 출력됨

#### `expect` 메서드

`unwrap` 대신 `expect`를 이용하고 좋은 에러 메시지를 제공하면 의도를 전달하면서 패닉의 근원을 추적하는걸 쉽게 해줌  

> 프로덕션급 품질의 코드에서 대부분의 러스타시안은 `unwrap`보다 `expect`를 선택하여 해당 연산이 항시 성공한다고 기대하는 이유에 대한 더 많은 맥락을 제공함  
> 이렇게 하면 가정이 틀렸다는 것이 입증될 경우 디버깅에 사용할 더 많은 정보를 확보할 수 있음

### 에러 전파하기

### [`Result` 관련 코드](./src/example/result.rs)