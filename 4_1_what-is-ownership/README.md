# Ownership

- Ownership 시스템은 Rust 언어가 메모리를 관리하는 방식, 규칙입니다.
- 프로그래밍 언어는 컴퓨터의 메모리를 직접 관리하거나, 더이상 사용되지 않는 메모리를 정기적으로 찾아 제거하는 가비지 컬렉터를 사용합니다.
- Rust 언어는 새로운 접근 방식인 Ownership 시스템을 사용합니다.

> Stack and Heap  
> Stack 구조에 저장된 모든 데이터는 알 수 있는 고정된 크기를 가져야 합니다.  
> 컴파일 시 알 수 없거나 크기가 변경될 수 있는 데이터는 Heap 구조에 저장됩니다.  
> > 메모리 할당자는 힙에 데이터를 넣을 때 충분히 큰 빈 지점을 찾아 할당하고, 해당 위치의 주소인 포인터를 반환합니다.  
> > 힙에 대한 포인터는 고정 크기이므로 스택에 저장할 수 있고, 실제 데이터를 가져오기 위해서는 이 포인터를 사용합니다.
>
> 할당자의 검색을 고려했을 때, 스택에 푸시(위치를 이미 알고 있음)하는 것이 힙에 할당(위치를 검색해야 함)하는 것보다 빠릅니다.

## Ownership 규칙

- Rust 언어의 각 값에는 소유자가 있습니다.
- 한 번에 하나의 소유자만 존재할 수 있습니다.
- 소유자가 스코프 밖으로 벗어나면 값은 버려집니다.

## 변수 범위

```rust
fn main () {
    let s = "hello"; // s는 이 지점부터 유효합니다.
    // s를 사용합니다.
} // 이 스코프는 끝났으므로, s는 더이상 유효하지 않습니다.
```

### String 타입

- String 타입은 데이터의 변경이 가능하지만 리터럴은 변경이 불가능한가?

```rust
fn main () {
    let s = String::from("hello"); // 리터럴로부터 동적인 텍스트를 힙으로부터 할당받습니다.
    
    s.push_str(", world!"); // push_str() 은 리터럴을 스트링으로 추가합니다.
}
```

- 문자열 리터럴의 경우 컴파일 시간에 내용을 알기 때문에 텍스트가 최종 실행 파일에 직접 하드코딩됩니다.
  - 문자열 리터럴이 빠르고 효유적인 이유
  - 그러나 이는 문자열 리터럴이 불변하기 때문에 가능한 것으로, 크기가 변경되는 텍스트 조각에 대해서는 바이너리에 넣기 힘듬.
- String 타입을 사용하여 변경 및 확장이 가능한 텍스트를 지원하려면 컴파일 시간에 알 수 없는 내용을 보관할 메모리의 양을 힙에 할당해야 합니다.
- 위의 예제에서 s 변수가 스코프를 벗어났을 때 Rust 언어는 `drop` 이라는 특별한 함수를 호출하여 메모리를 반환합니다.(`RAII` 패턴)

### 메모리와 할당, `Move`

```rust
fn main() {
    let x = 5;
    let y = x;
    // 고정 크기 데이터이기 때문에 복사본을 만들어 y 에 바인딩, 스택에 값 푸시
    
    let s1 = String::from("hello");
    let s2 = s1;
    // 힙에 저장되기 때문에 동일한 위치에 해당하는 포인터 참조
    // 만일 여기서 스코프를 벗어나게 되면 s1, s2 두 변수 모두 메모리를 해제하려고 하기 때문에 위험할 수 있음
}
```

- 위의 예시처럼 중복된 메모리 해제를 시도하지 않기 위해 Rust 언어는 `let s2 = s1` 이후에 `s1`을 더이상 유효하지 않은 것으로 간주합니다.
- Rust 언어에서는 이를 `Move`라고 부릅니다.

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1;
    // s1 은 더이상 유효하지 않습니다.
    println!("{}, world!", s1); // error!
}
```

- 즉, 힙에 저장된 자료형에 대해서는 기본적으로 얕은 복사가 일어나는 것과 유사합니다.
  - `clone`과 같은 방식으로 깊은 복사를 수행할 수도 있습니다.
- 스택에 저장되는 자료형의 경우에는 위의 경우처럼 무효화를 실행하지 않습니다.
- 스택에 저장됐다는 뜻은 고정 크기를 가진다는 뜻이기 때문에, 깊은 복사를 진행하더라도 리소스 낭비가 크지 않기 때문입니다.

### 매개변수와 반환값

#### 매개변수

```rust
fn main() {
    let s = String::from("hello"); // s가 스코프 안으로 들어왔습니다.
    takes_ownership(s); // s의 값이 함수 안으로 이동했습니다.
    // 여기서부터 s는 더이상 유효하지 않습니다.
    
    let x = 5; // x가 스코프 안으로 들어왔습니다.
    makes_copy(x); // x가 함수 안으로 이동했습니다.
    // i32는 복사가 되므로, 이후에도 x를 계속 사용해도 됩니다.
}
```

#### 반환값

```rust
fn main() {
    let s1 = gives_ownership(); // 반환값을 s1으로 이동시킵니다.
    
    let s2 = String::from("hello"); // s2가 스코프 안으로 들어왔습니다.
    
    let s3 = takes_and_gives_back(s2); // s2는 takes_and_gives_back 안으로 이동되었고,
    // 반환값은 s3으로 이동되었습니다.
} // 여기서 s3은 스코프 밖으로 벗어났고, `drop`이 호출됩니다. s2도 스코프 밖으로 벗어났지만
// 이동되었으므로 아무 일도 일어나지 않습니다. s1도 스코프 밖으로 벗어나 drop이 호출됩니다.

fn gives_ownership() -> String {
    let some_string = String::from("yours");
    
    some_string
}

fn takes_and_gives_back(a_string: String) -> String {
    a_string
}
```

### 값의 반환과 소유권의 이전

- 튜플을 사용하여 원하는 결과 값과 기본 값을 반환하면 값이 해제되는 것을 방지할 수 있습니다.

```rust
fn main() {
    let s1 = String::from("hello");
    
    let (s2, len) = calculate_length(s1);
    
    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len(); // len() 메소드는 스트링의 길이를 반환합니다.
    
    (s, length)
}
```

- 하지만 이 방법은 일반적으로 사용하기엔 너무 많은 작업이므로 참조라는 기능을 통해 해결할 수 있습니다.